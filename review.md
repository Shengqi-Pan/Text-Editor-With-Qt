# OOP要点整理

## 操作符dec、hex、oct的使用

```c++
#include<iostream.h>
void  main()
{
    int x=25;
    cout<<hex<<x<<' '<<dec<<x<<' '<<oct<<x<<'\n';
}
```

输出结果为：

`19  25  31 `

## 关于const

### const指针

* 因此以下语句是错误的：`pc[3]=‘x’`;下列语句是允许的：`pc=“efgh”;`

* 常指针把指针本身，而不是它指向的对象声明为常量。

  `char const pc=“abcd”;//常指针`

  `pc[3]=‘x’;//合法;pc="efgh";//出错`

* 如果用*const*定义的是一个整型常量，关键词*int*可以省略

* *实参与形参的结合是从左至右顺序进行的。因此指定默认值的参数必须放在形参表列中的最右端，否则出错*。

* 函数后的修饰符*const* ------ 表示该成员函数的执 行不会改变类的状态，也就是说不会修改类的数据成员。

### const对象保护

* const 对象的一般形式

```c++
类型名 const 对象名[(构造实参表列)];
const 类型名 对象名[(构造实参表列)];
```

*注意：常对象必须要有初值（因为以后不能改值了）。*

* 限定作用：定义为 const 的对象的所有数据成员的值都不能被修改。凡出现调用非const的成员函数，将出现编译错误。但构造函数除外。

  ```c++
  Time const t1(12,34,46);   // t1是常对象
  t1.set_Time();  // 编译错误PE，非const成员函数
  t2.show_Time();  // 错误，非const成员函数
  ```
  
* mutable成员:对数据成员声明为mutable（易变的）时，即使是const对象，仍然可以修改该数据成员值。

* **常对象成员**

  * 常数据成员:用 const 声明的常数据成员，其值是不能改变的。只能通过构造函数的参数初始化表对常数据成员进行初始化。

  * 常成员函数：成员函数声明中包含const时为常成员函数。此时，该函数只能引用本类中的数据成员，而不能修改它们（注意：可以改mutable成员）。

  * *注意：const是函数类型的一部分，在声明函数和定义函数时都要有const关键字，在调用时不必加const。*

  * *如果已定义了一个常对象，则只能调用其中的const成员函数，而不能调用非const成员函数(不论这些函数是否会修改对象中的数据)。如果需要访问对象中的数据成员，可将常对象中所有成员函数都声明为const成员函数，但应确保在函数中不修改对象中的数据成员。*

  * 指向常对象的指针：

    ```c++
    const 类型 *指针变量名
    ```

    *不能通过它来改变所指向目标对象的值，但指针变量的值是可以改变的；如果变量被声明为常对象，只能用指向常对象（变量）的指针变量指向它，而不能非const型指针变量去指向它.*

  * 指向某对象的常指针：指针的值不能改变
    ```c++
    类型* const 指针变量名
    ```
    

* const修饰函数

  ```c++
  int GetY() const;
  //该函数为只读函数，不允许修改其中的数据成员的值。
  const int * GetPosition();
  //修饰的是返回值，表示返回的是指针所指向值是常量。
  ```

## void指针

* *void* 通常表示无值，但将*void*作为指针的类型时，它却表示不确定的类型

  ```c++
      void  pa;//错误，不能声明void 类型的指针变量
       void* pc;//正确，可以声明void类型的指针
  ```

* void型指针可以接受任何类型的指针的赋值，但对已获值的void型指针，对它在进行处理，如输出或传递指针值时，则必须进行强制类型转换，否则会出错。

  ``` c++
  #include <iostream.h>
  main()
  {void *pc;
  int i=456;
  char c='a';
  pc=&i;
  cout<<*(int *)pc<<endl;
  pc=&c;
  cout<<*(char *)pc<<endl;
  return 0;}
  ```

## 重载

重载函数间不能只是函数的返回值不同，应至少在形参的个数、参数类型或参数顺序上有所不同。

## 函数模板

```c++
template <class T>
```

## 作用域标识符

```c++
#include <iostream.h>
int avar=10;
main()
{
int avar;
avar=25;
cout<<"local avar ="<<avar<<endl;
cout<<"global avar="<<::avar<<endl;
return 0;
}
```

## new标识符

```c++
 使用new为多维数组分配空间时，必须提供所有维的大小，如：int *pi=new int[2][3][4];
其中第一维的界值可以是任何合法的表达式，如：
 int  i=3;
 int  *pi=new  int[ i ][2][3];
new可在为简单变量分配内存空间的同时，进行初始化。这时的语法形式为：
     指针变量=new  类型名(初始值列表) 
例如：
p=new int(99);   // 动态分配内存，并将99作为初始值赋给它
```
## 引用

类型标识符    `&引用名=目标变量名；`
如：int a; 
       int &ra=a;   //定义引用ra,它是变量a的引用，即别名
由于指针变量也是变量，所以，可以声明一个指针变量的引用。
方法是： `类型标识符 *&引用名=指针变量名；`

```c++
#include <iostream.h>
void main()
{
  int *a;      //定义指针变量a
  int *&p=a;   //定义引用p，初始化为指针变量a，所以p是a的引用（别名）
  int b=10;
  p=&b;        //等价于a=&b，即将变量b的地址赋给a。
  cout<<*a<<endl;    //输出变量b的值
  cout<<*p<<endl;    //等价于cout<<*a;
cout<<a<<endl; //输出a和p的地址
cout<<p<<endl;
}
```

* 不能声明引用的引用，也不能定义引用的指针

* 不能建立数组的引用，因为数组是一个由若干个元素所组成的集合，所以就无法建立一个数组的别名。

* 不能建立空指针的引用，如：不能建立int &rp=NULL;

* 不能建立空类型void的引用，如：不能建立`void &ra=3;`因为尽管在C++语言中有void数据类型，但没有任何一个变量或常量属于void类型。

* 函数可以返回一个引用，将函数说明为返回一个引用的主要目的是：为了将函数用在赋值运算符的左边。
     要以引用返回函数值，则函数定义时要按以下格式：
  
  ```c++
  类型标识符 &函数名（形参列表及类型说明）
   {函数体}
  ```
  
* 用const限定引用
     声明方式：`const 类型标识符 &引用名=目标变量名；`
     用这种方式声明的引用，不能通过引用对目标变量的值进行修改,从而使引用的目标成为const，达到了引用的安全性。 

## 类和对象

* private处于类体中第一部分时，关键字private可以省略。

* 数据成员可以是任何数据类型，但不能用自动(auto)、寄存器(register)或外部(extern)进行声明。

* 不能在类声明中给数据成员赋值。C++规定，只有在类对象定义之后才能给数据成员赋初值

* 在声明类的同时定义的对象是一种全局对象，在它的生存期内任何函数都可以使用它。

* 在类的内部所有成员之间都可以通过成员函数直接访问，但是类的外部不能访问对象的私有成员。

  *例如下面是一个存在错误的程序*

  ```c++
  #include <iostream.h>
  class Date {
  public:
  	    void setDate(int y,int m,int d);
  	    void showDate();
  private:
      int year;
      int month;
      int day;
  };
  void Date∷setDate(int y,int m,int d)
  {
           year=y;
  	    month=m;
  	    day=d;
  }
  inline void Date∷showDate()
  {
      cout<<year<<"."<<month<<"."<<day<<endl;
  }
  void main()
  {
  	    Date date1,date2;
  	    cout<<"Date1 set and output:"<<endl;
  	    date1.setDate(1998,4,28);
      cout<<date1.year<<"."<<date1.month<<"."<<date1.day<<endl; //错误
  	    cout<<"Date2 set and output："<<endl;
  	    date2.setDate(2002,11,14);
  	    cout<<date2.year<<"."<<date2.month<<"."<<date2.day<<endl; //错误
  }
  ```

  *应该改为：*

  ```c++
  date1.showDate(); 
  date2.showDate(); 
  ```

* 说明为私有的成员只能被类中成员函数访问,不能在类的外部,通过类的对象进行访问。

* **对象赋值语句：**两个同类型的变量之间可以相互赋值。同类型的对象间也可以进行赋值，当一个对象赋值给另一个对象时，所有的数据成员都会逐位拷贝。

  ```c++
  #include<iostream.h>
      class abc{
  	......
     };
  	main()
  	{    abc o1,o2;
  	     o1.init(12,34);
  	     o2=o1;        // 将对象o1数据成员的值赋给对象o2
  	     ......
  	}
  ```

  *上面的对象赋值是通过缺省的赋值运算符函数实现的。当类中存在指针时，使用缺省的赋值运算符进行对象赋值，可能会产生错误。*

* 类的构造函数是在对象进入其作用域时（对象使用前）调用的。 

* 构造函数创建对象的两种语法

  ```c++
  类名  对象名[(实参表)];
  类名 *指针变量 = new 类名[(实参表)];
  ```

* 成员初始化表的构造函数

  对于常量类型和引用类型的数据成员,不能在构造函数中用赋值语句直接赋值,C++提供初始化表进行置初值。

  * 带有成员初始化表的构造函数的一般形式如下:

  	```c++
  类名::构造函数名([参数表])[:(成员初始化表)]
  {
      // 构造函数体
  }
  成员初始化表的一般形式为:
    数据成员名1(初始值1),数据成员名2(初始值2),…… 
		```

  * 如果需要将数据成员存放在堆中或数组中，则应在构造函数中使用赋值语句，即使构造函数有成员初始化表也应如此。

    ```c++
    class  C{
    public:
        C(int I,char Ch,float F,char N[]):i(I),ch(Ch),f(F)//学习初始化列表写法
        { strcpy (name,N);}
    private:
        int i;
        char ch;
        float f;
        char name[25];
    };
    ```
    
  * *<font color=Red>类成员是按照它们在类里被声明的顺序初始化的,与它们在初始化表中列出的顺序无关。</font>*
  
    ```c++
    #include<iostream.h>
    class D {
    public:
    	    D(int i):mem2(i),mem1(mem2+1)
    	    {
    	        cout<<"mem1: "<<mem1<<endl;
    	        cout<<"mem2: "<<mem2<<endl;
        }
    private:
    	    int mem1;
    	    int mem2;
    };
    void main()
    {
    	    D d(15);
    }
    //运行结果
    //mem1: -858993459
    //mem2: 15
    ```
  
* 拷贝构造函数

  * 调用拷贝构造函数的三种情况

    * 当用类的一个对象去初始化该类的另一个对象时。

      ```c++
Coord p2(p1); // 用对象p1初始化对象p2,拷贝构造函数被调用(代入法)
      Coord p3=p1; // 用对象p1初始化对象p3,拷贝构造函数被调用(赋值法)
      			//这时需要调用拷贝构造函数 
      ```
      
    * 当函数的形参是类的对象,调用函数,进行形参和实参结合时。  
    
      ```c++
         fun1(Coord p)      // 函数的形参是类的对象
         { 
            p.print();
         }
         main()
        {
          Coord p1(10,20);
          fun1(p1);          // 当调用函数,进行形参和实参结合时,
                                    调用拷贝构造函数
          return 0;
        }
      ```
    
    * 当函数的返回值是对象,函数执行完成,返回调用者时。
    
      ```c++
      Coord fun2()
      {    Coord p1(10,30);
          return p1;    }    // 函数的返回值是对象
      
      main()
      {    Coord p2;
          P2=fun2(); // 函数执行完成,返回调用者时,调用拷贝构造函数                                  
          return 0;  }
      ```
  
* 析构函数

  * 析构函数不能重载，一个类中只有一个
  * auto局部对象：局部自动对象(例如在函数中定义的对象)，则在建立对象时调用其构造函数。如果函数被多次调用，则在每次建立对象时都要调用构造函数。在函数调用结束、对象释放时先调用析构函数。
  * static局部对象：如果在函数中定义静态局部对象，则只在程序第一次调用此函数建立对象时调用构造函数一次，在调用结束时对象并不释放，因此也不调用析构函数，只在main函数结束或调用exit函数结束程序时，才调用析构函数.

## 内联函数

```c++
inline 返回类型  类名::成员函数名(参数表)
{
       // 函数体
}
```

*注意：在类内声明时不用inline*

*注意：使用inline说明内联函数时，必须使函数体和inline说明结合在一起，否则编译器将它作为普通函数处理。*

例：

```c++
inline  void Coord:: setCoord(int ,int);
```

  不能说明这是一个内联函数。

## 指向类的成员的指针

* 指向成员的指针只能访问公有数据成员和成员函数。

* 使用要先声明，再赋值，然后访问。

  ```c++
  声明：类型说明符 类名:: *数据成员指针名；
  //例如：
  int A∷*pc2;
  赋值：数据成员指针名＝&类名:: 数据成员名
  //例如:
  pc2=&A∷z;     // 给数据成员指针pc2赋值    // 
  
  使用：对象名. *数据成员指针名
              对象指针名-> *数据成员指针名
  ```

  

## 指向成员函数的指针

```c++
声明：类型说明符  (类名∷ *指针名)(参数表); 
赋值：成员函数指针名 = 类名∷成员函数名; 
使用：(对象名.*成员函数指针名)(参数表)  ;
     （对象指针名 -> *成员函数指针名）(参数表) ;
//例如：
   int (Coord∷*pc_getx)();  
   pc_getx=Coord∷getx; 
```

## 静态成员

静态数据成员用关键字static声明，该类的所有对象维护该成员的同一个拷贝，***必须在类外定义和初始化，用(::)来指明所属的类。***

在类的声明中只能声明静态数据成员的存在。由于类的声明是抽象的，静态数据成员的初始化需要在类的外部进行，通过类名对它进行访问。

静态数据成员初始化的格式如下：

```c++
<数据类型><类名>∷<静态数据成员名>=<值>；
```

初始化时不加该成员的访问权限控制符private，public等。

引用静态数据成员时，采用如下格式：(只能访问公有静态数据成员)

```c++
  可用类名访问：  类名::静态数据成员
  也可用对象访问： 对象名.静态数据成员
                对象指针->静态数据成员
```

静态成员函数可以直接访问该类的静态数据成员和函数成员；而访问非静态数据成员，必须通过参数传递方式得到对象名，然后通过对象名来访问。

定义静态成员函数的格式如下:

```c++
static 返回类型 静态成员函数名（参数表）;
```

使用目的：在对象建立之前处理静态数据成员或全局变量,与静态数据成员类似, 使用公有静态成员函数的一般格式有如下几种:

   ```c++
类名::静态成员函数名(实参表)
对象. 静态成员函数名(实参表)
对象指针->静态成员函数名(实参表)
   ```

* 静态成员函数可以定义成内嵌的，也可以在类外定义，在类外定义时不能用static前缀。
* 使用静态成员函数的一个原因是，可以用它在建立任何对象之前处理静态数据成员。这是普通成员函数不能实现的。
* 静态成员函数中没有指针this，所以静态成员函数不访问类中的非静态数据成员，若确实需要则只能通过对象名（作为参数）访问。

通过指针可以访问类的静态成员或静态成员函数

```c++
 #include<iostream.h>
 class myclass {
    public:
       myclass()                             // 构造函数,每定义一个对象,
         { ++i; }                                             // 静态数据成员i加1
       static int i;                             // 声明静态数据成员i
	}; 
  int myclass::i=0;                       // 静态数据成员i初始化,  
                                                        //不必在前面加static
  main()
  {  int *count=&myclass::i; 
      myclass ob1,ob2,ob3,ob4;
      cout<<“ myclass::i= ”<<*count<<endl;   
      return 0;  } 
```

```c++
#include<iostream.h>
class myclass {
public:
    myclass()       
      {   ++i;  }
    static int geti()  	
      {   return i;  }
private:
    static int i;     
  };
int myclass::i=0;     	
main()
{  int (*get)()=myclass::geti;  
   myclass ob1,ob2,ob3;
   cout<<"myclass∷i="<<(*get)()<<endl; 	
   return 0;
}
```

## 友元

* 友元函数的声明：
  位置：当前类体中.
  格式：函数名前加friend
* 友元函数的定义：
  类体外：同一般函数（函数名前不能加    类名::）
  类体内：函数名前加friend
* <font color=red>友元函数没有*this*指针，它通过入口参数（该类对象）来访问对象的成员</font>
* 注意友元函数常常伴随着提前引用问题
* 关于友元类
  * 友元关系是单向的，不具有交换性
    即若类X是类Y的友元，但类Y不一定是类X的友元。
  * 友元关系不具有传递性
    即若类X是类Y的友元，类Y是类Z的友元，但类X不一定是类Z的友元。

## 对象成员

> 关键问题是对象成员的初始化，也就是构造函数如何设计的问题

```c++
X::X(形参表0):对象成员名1(形参表1),…,
               对象成员名i(形参表i) ,…,对象成员名n(形参表n)
{
   // …构造函数体
} 
```

例如：

```c++
#include<iostream.h>
class A{
public:
    A(int x1，float y1)
    { x=x1; y=y1; }
    void show() 
    { cout<<"\n x="<<x<<" y="<<y; }
private:
    int x; 
    float y;
}; 
class B{
public:
  B(int x1,float y1,int z1):a(x1,y1)
   { z=z1; }       
  void show()
   { a.show(); 
     cout<<" z="<<z; } 
private:
    A a;           
    int z;
};
main()
{ B b(11,22,33); 
  b.show(); 
  return 0; 
} 
```

具有对象成员的类的构造函数的另一种形式如下：

```c++
B(A a1，int z1):a(a1)
 { z=z1; }
main()
 { A a(11,22);
   B b(a,33);
   b.show();
   return 0;
}
```

这时析构函数不需要析构其对象成员。

## 继承与派生

### 书写格式

```c++
class  派生类名:继承方式  基类名 
{
       //派生类新增的数据成员和成员函数
    }; 
```

### <font color=red>基类成员在派生类中的访问属性</font>

***<font color=red>inaccessible>private>protected>public</font>***

*基类的private成员在私有派生类中是不可直接访问的,所以无论是派生类成员还是通过派生类的对象,都无法直接访问从基类继承来的private成员,但是可以通过基类提供的public成员函数间接访问。*

### 派生类对象当作基类使用

* 派生的对象可以赋给基类的对象。

* 派生类的对象可以初始化基类的引用

  ```c++
  derive d;
  base &br=d;
  ```

* 派生类的对象的地址可以赋给指向基类的指针

  ```c++
  derived d;
  base *pb=&d;
  ```

* 上述三种情形中，在后两种情况下，通过指针或引用只能访问对象d中所继承的基类成员。

### 多继承

```c++
    class 派生类名:继承方式1  基类名1,…,继承方式n  基类名n{
          // 派生类新增的数据成员和成员函数
     }; 
```

不写继承方式则默认*private*继承

### 虚基类

声明：定义派生类时声明

```c++
class  派生类名:virtual  继承方式  类名{
    //…
   } 
//下面的写法也可
class  派生类名:继承方式  virtual  类名{
    //…
   } 
```

### 派生类的构造与析构

> 基类的构造函数和析构函数不能被继承，一般派生类要加入自己的构造函数。

* 派生类含有内嵌对象成员时，构造函数形式：

  ```c++
  派生类名(参数总表):基类名(参数表1),内嵌对象名1(内嵌对象参数表1),…,内嵌对象名n(内嵌对象参数表n)
   {
       // 派生类新增成员的初始化语句
      } 
  ```

  *  在定义派生类对象时,构造函数的执行顺序如下:

    * 调用基类的构造函数;
    * 调用内嵌对象成员（子对象类）的构造函数<font color=red>（有多个对象成员时,调用顺序由它们在类中声明的顺序确定）</font>;
    * 派生类的构造函数体中的内容

    *撤消对象时,析构函数的调用顺序与构造函数的调用顺序正好相反。*

*  注意：

  * 当基类构造函数不带参数时，派生类可不定义构造函数，但基类构造函数带有参数，则派生类必须定义构造函数。
  * 若基类使用缺省构造函数或不带参数的构造函数，则在派生类中定义构造函数时可略去“：基类构造函数名（参数表）”
  * 基类和派生类的析构函数是各自独立的。

* 多继承的构造函数

  ```c++
  派生类名(参数总表):基类名1(参数表1),基类名2(参数表2),…,基类名n(参数表n)
      {
             // 派生类新增成员的初始化语句
       }
  ```

  * 构造函数执行顺序：*先执行基类构造函数，再执行对象成员的构造函数，最后执行派生类构造函数。*
    * 处于同一层次各基类构造函数执行顺序，取决于声明派生类时所指定各基类的顺序，与派生类构造函数中所定义的成员初始化列表的各项顺序无关。

* 虚基类的初始化

  * 建立一个对象时,如果这个对象中含有从虚基类继承来的成员,则虚基类的成员是由最远派生类的构造函数通过调用虚基类的构造函数进行初始化的。该派生类的其他基类对虚基类构造函数的调用都自动被忽略。 
  * 若同一层次中同时包含虚基类和非虚基类,应先调用虚基类的构造函数,再调用非虚基类的构造函数,最后调用派生类构造函数;
  * 对于多个虚基类,构造函数的执行顺序仍然是先左后右,自上而下;
  * C++规定，虚基类子对象是由最派生类的构造函数通过调用虚基类的构造函数进行初始化的。如果一个派生类有一个直接或间接的虚基类，那么派生类的构造函数的成员初始列表中必须列出对虚基类构造函数的调用，如果未被列出，则表示使用该虚基类的缺省构造函数来初始化派生类对象中的虚基类子对象。

### 赋值兼容原则

可以把指向派生类对象的指针赋值给指向基类对象的指针。例如:

```c++
Derived *dptr;
Base *bptr=dptr;
```

* *注意*

  * *声明为指向基类对象的指针可以指向它的公有派生的对象，但不允许指向它的私有派生的对象。*

  * *声明为指向基类对象的指针，当其指向公有派生类对象时，只能用它来直接访问派生类中从基类继承来的成员，而不能直接访问公有派生类中定义的成员。*

  * *若想访问其公有派生类的特定成员，可以将基类指针用显示类型转换为派生类指针。*

    ```c++
    class  A {
        //…
    public：
        void  print1();
    };
    class  B：public  A {
        //…
    public：
        print2();
    };
    void  main()
    {
        A  op1,*ptr;   	// 定义基类A的对象op1和基类指针ptr
        B  op2;        	// 定义派生类B的对象op2
        ptr=&op1;    	// 将指针ptr指向基类对象op1
        ptr->print1(); 	// 调用基类函数print1()
        ptr=&op2;       	// 将指针ptr指向派生类对象op2
        ptr->print1();     // 调用对象op2从其基类继承来的成员函数print1()
        ptr->print2();     // 错误，基类指针ptr不能访问派生类中定义
                                          //的成员函数print2()
    //应当改为：
        ((B*)ptr)-> print2();
    ```

 ## 虚函数

```c++
virtual<类型说明符><函数名>(<参数表>)
//被关键字virtual说明的函数称为虚函数
{
    //函数体
}
```

注意：<font color=red>①通过定义虚函数来使用C++提供的多态机制时，派生类应该从它的基类公有派生。赋值兼容规则成立的前提条件是派生类从其基类公有派生
②使用对象名和点运算符的方式也可以调用虚函数，但是这种调用在编译时进行的是静态联编
③必须首先在基类中定义虚函数
④虚函数必须是其所在类的成员函数，而不能是友元函数，也不能是静态成员函数，因为虚函数调用要靠特定的对象来决定该激活哪个函数。但是虚函数可以在另一个类中被声明为友元函数。
⑤内联函数、构造函数不能是虚函数。⑥类外定义虚函数不加virtual关键字。</font>

### 虚析构函数

*如果一个类的析构函数是虚函数，那么，由它派生而来的所有派生类的析构函数也是虚析构函数，不管它是否使用了关键字virtual进行说明。*

```c++
virtual ~类名（）；
```

### 虚函数重载与普通函数重载的区别

* 普通的函数重载时，其函数的参数个数或参数类型必须有所不同，函数的返回类型也可以不同。 
* 当重载一个虚函数时，也就是说在派生类中重新定义虚函数时，要求函数名、返回类型、参数个数、参数的类型和顺序与基类中的虚函数原型完全相同。
* 如果仅仅返回类型不同，其余均相同，系统会给出错误信息;
* 若仅仅函数名相同，而参数的个数、类型或顺序不同，系统将它作为普通的函数重载，这时将丢失虚函数的特性。

### 多继承时的虚函数

```c++
	#include<iostream.h>
	class Base1{
	public：
	    virtual void fun()       //定义fun()是虚函数
	    {   cout<<"--Base1--\n";  }
	};
	class Base2{
	public：
	    void fun()         //定义fun()为普通的成员函数
	    {   cout<<"--Base2--\n"; }
	};
	class Derived：public Base1,public Base2{
	public：
	    void fun()
	    {   cout<<"--Derived--\n";  }
	};
    void main()
	  {
	    Base1 obj1,*ptr1;  
	    Base2 obj2,*ptr2;  
	    Derived obj3;     
         ptr1=&obj1;       
	    ptr1->fun();        
         ptr2=&obj2;         
         ptr2->fun(); 
         ptr1=&obj3;    
         ptr1->fun(); 
         ptr2=&obj3; 
         ptr2->fun();  
       }
/*运行结果：
--Base1--
--Base2--
--Derived--
--Base2—
*/
```

### 纯虚函数与抽象类

```c++
virtual  <函数类型>  <函数名> ( 参数表 ) = 0；
```

一个具有纯虚函数的类称为**抽象类**；不允许从具体类派生出抽象类；抽象类不能用作参数类型、函数返回类型或显式转换的类型；可以声明指向抽象类的指针或引用，此指针可以指向它的派生类，进而实现多态性；抽象类的析构函数可以被声明为纯虚函数，这时，应该至少提供该析构函数的一个实现。

## 运算符重载

* 类属关系运算符“.”、作用域分辨符“::”、成员指针运算符“*”、sizeof运算符和三目运算符“？：”不能重载。
* 重载之后运算符的优先级和结合性都不能改变，单目运算符只能重载为单目运算符，双目运算符只能重载为双目运算符。
* 运算符的重载形式有两种：重载为类的成员函数;重载为类的友元函数。
* 不能改变运算符操作数的个数；不能改变运算符原有的语法结构。

```c++
//重载为类的成员函数格式
<类型> <类名>:: operator <要重载的运算符>（形参表）
     {
         函数体
      }
//重载为类的友元函数格式
friend  <函数类型>  operator  <运算符>(形参表)
{
      函数体；
}
//在重载为友元函数的二元运算符被定义时，格式为
<函数返回类型> operator <重载运算符>(<形参1>, <形参2>)
{ 
	函数体;
}
//在重载为友元函数的一元运算符被定义时，格式为
<函数返回类型> operator<一元运算符> (类名 &对象)
{
	函数体
}
```

### 运算符重载为成员函数

#### 双目运算：oprd1 B oprd2

把B重载为oprd1所属类的成员函数，只有一个形参，形参的类型是oprd2所属类。例如，经过重载之后，表达式oprd1 + oprd2就相当于函数调用

 ```c++
oprd1.operator +(oprd2)
 ```

#### 单目运算

##### 前置单目运算：U oprd

把U重载为oprd所属类的成员函数，没有形参。例如，“++”重载的语法形式为：

```c++
 <函数类型>  operator  ++( );
```

 `++ oprd` 就相当于函数调用`oprd.operator  ++( );`

##### 后置单目运算 oprd V

运算符V重载为oprd所属类的成员函数，带有一个整型(int)形参。例如，后置单目运算符“- -”重载的语法形式为：

```c++
<函数类型>  operator -- ( int );
```

`oprd--` 就相当于函数调用`oprd.operator --(0);`

#### 总结

> 对于++（或--）运算符的重载，因为编译器不能区分出++（或--）是前置的还是后置的，所以要加上(int)来区分。

```c++
operator++();   //重载前置++
operator++(int); //重载后置++
operator--();   //重载前置--
operator--(int); //重载后置--
```

### 运算符重载为友元函数

#### 双目运算：oprd1 B oprd2

双目运算符B重载为oprd1所属类的友元函数，该函数有两个形参，表达式`oprd1 B oprd2`就相当于函数调用`operator B (oprd1，oprd2)`。

#### 单目运算

##### 前置单目运算U oprd

前置单目运算符U重载为`oprd`所属类的友元函数，表达式U oprd相当于函数调用`operator U(oprd)`。

##### 后置单目运算oprd V

后置单目运算符V重载为`oprd`所属类的友元函数，表达式oprd V相当于函数调用`operator V(oprd，int)`。

### 输入输出操作符的重载

#### 输出操作符<<的重载

```c++
ostream & operator << (ostream &,const 自定义类 &);
```

#### 输入操作符>>的重载

```c++
istream & operator >> (istream &, 自定义类 &);
```

> 和输出操作符不同的是输入操作符必须处理错误和文件结束的可能性。

### 比较运算符重载

```c++
bool operator == ( 类型名 ) ;
bool operator !=  (类型名 ) ;
```

### 下标运算符[]重载

```c++
类型名 &operator [ ] ( int)
//关于左值与右值的区别
a[3] = 5;// 这里用的是double & operator[](int i); 
double x = a[3];// 这里用的是double operator[](int i)const;
```

### new与delete运算符重载

```c++
void *operator new ( size_t  size)
void operator delete( void * p )
```

### 强制类型转换运算符重载

```c++
operator 类型名 () ;
//其后也可以加const限定,也即
operator 类型名 () const;
```

特点:没有返回值、功能类似强制转换

### 赋值运算符重载

> 对于赋值运算符重载一般包括以上几个步骤，<font color=red>**首先要检查是否自赋值，如果是要立即返回，如果不返回，后面的语句会把自己所指空间删掉，从而导致错误**</font>；第二步要释放原有的内存资源；第三步要分配新的内存资源，并复制内容；第四步是返回本对象的引用。如果没有指针操作，则没有第二步操作。
> 赋值运算符与拷贝构造函数在功能上有些类似，都是用一个对象去填另一个对象，但拷贝构造函数是在对象建立的时候执行，赋值运算符是在对象建立之后执行。

### 总结与整理

* 所有赋值运算符改变左值。所有赋值运算符返回值对于左值应该是nonconst引用
* 重载不能改变该运算符用于内置类型时的含义，正如程序员不能改变运算符+用于两个int型相加时的含义。
* 运算符函数的参数至少有一个必须是类的对象或者类的对象的引用，这种规定可以防止程序员运用运算符改变内置类型的函义。
* 赋值（=）、下标（[]）、调用（( )）和成员访问箭头（->）等操作符必须定义为成员，将这些操作符定义为非成员函数在编译时标记为错误。
* 像赋值一样，复合赋值操作符通常应定义为类的成员函数。定义成非成员函数不会出现编译错误。

## 类型重载

```c++
class <类名1>
     {
        public:
           operator <类名2>( );
           ……
      };
      <类名1>::operator <类名2>()
      {     函数体； }
```

> 其中`operator<类名2>`为转换函数的函数名，转换函数的作用是将类型1的对象转换成类型2的对象。类中类型转换函数必须是非静态的成员函数，不能定义成友元函数，无返回值类型且不带参数。

## 模板

### 模板函数

```c++
template <class 类型参数>
返回类型   函数名（模板形参表）
{
    函数体
}
//下面的形式也被接受
template<typename 类型参数>
返回类型   函数名（模板型参表）
 {
     函数体
 }
 //函数模板调用方式
 函数名（实参数表）；
```

* 在函数模板中允许使用多个类型的参数，template定义部分的每个模板参数前必须有关键字class

  ```c++
  #include <iostream.h>  //C++IO流头文件
  //定义两个参数的函数模板
  template<class type1, class type2>
  void myfunc(type1 x, type2 y)
  {
  	cout<<x<< “    “ << y<<endl;
  }
  ```

* 在template语句与函数模板定义语句之间不允许有别的语句

  ```c++
  template<class T>
  int i;                //编译错误，不允许有别的语句
  T max(T x, T y)
  {
       return (x>y)?x:y;
  }
  ```

* 函数可以带有模板参数表中未给出的、已存在的数据类型的参数。

* 实例化T的各模板之间必须保持完全的一致，否则会发生错误。发生错误时，解决方案为采用强制类型转换，或用非模板函数重载函数模板。

  * 声明一个非模板函数的原型，例如

    ```c++
    template<class T>
    T max(T x, T y)
    {
    	return (x>y)?x:y;
    }
    int max(int, int)；//只声明一个非模板函数的原型
    void func(int i,char c)
    {
        max(i, i);    //正确 ,调用max(int,int)
        max(c, c);  //正确 ,调用max(char,char)
        max(i, c);   //正确 ,调用 max(int,int),使用隐式类型转换
        max(c, i);   //正确 ,调用max(int,int),使用隐式类型转换
    }
    ```

  * 定义一个完整的非模板函数重载模板函数,比如：在上面程序的模板定义下面定义如下函数：

    ```c++
    char *max(char *x, char *y)
    {
    	return (strcmp(x,y)>0)?x:y;
    }
    ```

* 重载模板函数调用顺序

  * 寻找一个参数完全匹配的函数，如果找到就调用它。
  * 寻找一个函数模板，将其实例化，产生一个匹配的模板函数。若找到了，就调用它。
  * 尝试低一级的对函数的重载方法。例如通过类型转换可产生参数匹配等，若找到了，就调用它。

### 类模板

```c++
template <class Type>
class ClassName
{
    //具体内容
};
//下面的形式也被接受
template <typename Type>
class ClassName
{
   //具体内容
};
//模板类调用形式
ClassName<类型实参表> object；
```

**在类定义体外定义成员函数时，若此成员函数中有类型参数存在，则需要在函数体外进行模板声明，并且在函数名前的类名后缀上“<T>”。**

* 在每个类模板定义之前，都需要在前面加上模板声明，如：

  ```c++
  template<class type>
  ```

  类模板在使用的时候，必须在名字后面缀上模板参数`<type>`,例如`stack<int>`

* 模板类可以有多个模板参数

* 考试中遇到模板考虑填写`<>`

## 异常处理

* try块和catch块作为一个整体出现，catch块是try-catch结构中的一部分，必须紧跟在try块之后，不能单独使用，在二者之间也不能插入其他语句。但是在一个try-catch结构中，可以只有try块而无catch块。即在本函数中只检查而不处理，把catch处理块放在其他函数中。

* try和catch块中必须有用花括号括起来的复合语句，即使花括号内只有一个语句，也不能省略花括号。

* 一个try-catch结构中只能有一个try块，但却可以有多个catch块，以便与不同的异常信息匹配。

* catch还可以有另外一种写法，即除了指定类型名外，还指定变量名，如

  ```c++
  catch(double d)
  ```

  此时如果throw抛出的异常信息是double型的变量a，则catch在捕获异常信息a的同时，还使d获得a的值，或者说d得到a的一个拷贝。

* 如果在catch子句中没有指定异常信息的类型，而用了删节号“…”，则表示它可以捕捉任何类型的异常信息.这种catch子句应放在try-catch结构中的最后，相当于“其他”。如果把它作为第一个catch子句，则后面的catch子句都不起作用。

* try-catch结构可以与throw出现在同一个函数中，也可以不在同一函数中。当throw抛出异常信息后，首先在本函数中寻找与之匹配的catch，如果在本函数中无try-catch结构或找不到与之匹配的catch，就转到离开出现异常最近的try-catch结构去处理。

* 某些情况下，在throw语句中可以不包括表达式，如

  ```c++
  throw;//表示“我不处理这个异常，请上级处理”。
  ```

* 如果throw抛出的异常信息找不到与之匹配的catch块，那么系统就会调用一个系统函数terminate，使程序终止运行。

* 如果想声明一个不能抛出异常的函数，可以写成以下形式:

  ```c++
  double triangle(double,double,double) throw();//throw无参数
  ```

* <font color=red>**在异常处理中，try中的局部对象会被析构，析构对象的顺序与构造的顺序相反，然后执行与异常信息匹配的catch块中的语句。**</font>

## 命名空间

```c++
//简化命名空间
//方法1
namespace Television//声明命名空间，名为Television
 {…}
//可以用一个较短而易记的别名代替它。如
namespace TV = Television;//别名TV与原名Television等价
//方法2
using ns1::Student;
//using声明的有效范围是从using语句开始到using所在的作用域结束
```

# 例题分析

```c++
#include<iostream>
using namespace std;
class Parent{
	int i;
public:
	Parent(int ii):i(ii){
		cout << "Parent(int ii)\n";
	}
	Parent (const Parent& b):i(b.i){
		cout << "Parent(const Parent&)\n";
	}
	Parent():i(0){
		cout <<"Parent()\.";
	}
	friend ostream& operator<<(ostream&os,const Parent& b){
		return os<< "Parent:"<<b.i<<endl;
	}
};
class Member{
	int i;
	public:
		Member(int ii):i(ii){
			cout << "Member(int ii)\n";
		}
		Member(const Member&m):i(m.i){
			cout<<"Member(const Member&)\n"; 
		}
		friend ostream& operator<<(ostream&os,const Member&m){
			return os<<"Member:"<<m.i<<endl;
		} 
};
class Child:public Parent{
	int i;
	Member m;
	public:
		Child(int ii):Parent(ii),i(ii),m(ii){
			cout << "Child(int ii)\n";
		}
		friend ostream& operator<<(ostream& os,const Child& c){
			return os<<(Parent&)c<<c.m<<"Child:"<<c.i<<endl;
		}
};
int main(){
	Child c(2);
	Child c2=c;
	cout<<c2;
}
/*运行结果
Parent(int ii)
Member(int ii)
Child(int ii)
Parent(const Parent&)
Member(const Member&)
Parent:2
Member:2
Child:2
*/
```

```c++
//改错题
#include <iostream>
#include <cstring>
using namespace std;
class A{
int i;
public:
A(int ii):i(ii){}	//改为A(int ii=0):i(ii){}
};
class B:public A{
	char *p;
public:
	B(char *p)
	{
		p=new char[strlen(p)+1];//改为B::p=new char[strlen(p)+1];
		strcpy(p,p);//改为strcpy(B::p,p);
	}
	~B()
	{
		delete p;//改为delete []p
	}
};
int main()
{
	B b("hello");
	A *p = new B("world!");
}
```

> 注意调用静态成员函数时，不能用对象去调用，应该用	**类名::函数名**	的方式去调用

```c++
//新建一个字符串变量的通用手法
m_data=new char[strlen(str)+1];
```

```c++
#include <iostream>
#include <cstring>
using namespace std;
	int &f(int &i)
	{
		i+=10;
		return i;
	 } 
int main()
{
	int k=0;
	int &m=f(k);
	cout<<k<<endl;
	m=20;
	cout<<k<<endl;
}
/*输出结果
10
20*/
```

```c++
dynamic_cast <type-id> (expression)
/*dynamic_cast运算符的主要用途：将基类的指针或引用安全地转换成派生类的指针或引用，并用派生类的指针或引用调用非虚函数。如果是基类指针或引用调用的是虚函数无需转换就能在运行时调用派生类的虚函数。*/
```

```c++
//模板类的常规操作方式
new T[strlen(...)+1];
delete []...;
const...;	//const限定
throw...;
catch(...);	//尤其是当看到代码开头定义了新的类时
```

